Document 1: SigFile - Phased Design Document

1. Introduction & Vision

Product: SigFile

Vision: To create the essential tool for capturing, preserving, and leveraging the developer's signature – the rationale, context, decisions, and unique thinking ("the why") behind code changes. SigFile transforms development history from just code snapshots (Git) into a verifiable, searchable knowledge base of intent, ultimately evolving into an AI-powered agent that provides proactive guidance and preserves collaborative intelligence.

Core Problem: Valuable context, rationale, and decision-making processes are lost in ephemeral chats, undocumented meetings, or individual memory, leading to repeated mistakes, slower onboarding, difficult debugging, and loss of unique team "signatures."

Core Solution: A system to easily log contextual "SigFile" entries linked to specific code states (Git commits), secured with digital signatures, stored accessibly (initially local, then customer-hosted), and eventually leveraged by an AI agent.

2. Core Concepts

SigFile Entry: A structured record (JSON initially) containing metadata about a code change or development task. Key fields include:

entry_id: Unique identifier (UUID).

timestamp: Creation time.

author_id: Identifier of the developer (e.g., email, user ID).

task_id (Optional/Phase 2+): Group related entries.

linked_files: Array of relevant file paths.

linked_commit_hash: Specific Git commit hash the entry pertains to.

decision_type: (e.g., Implemented, Rejected, AlternativeConsidered, Discussion, AI_Suggestion_Accepted, AI_Suggestion_Rejected).

rationale: Free-text field capturing the "why" – the core signature.

tags: Array of keywords for categorization.

digital_signature: Cryptographic signature of the entry content using the author's private key.

author_public_key_ref: Reference to the author's public key used for signing.

(Future) linked_snapshot_id: Reference to an external system snapshot.

Developer Signature: The unique combination of rationale, style, choices, and context captured in SigFile entries, attributable to an individual or team.

Digital Signature (Cryptography): Using standard asymmetric cryptography (e.g., GPG/PGP or similar) to ensure Authenticity, Integrity, and Non-repudiation of SigFile entries. This makes the log a verifiable audit trail.

Customer-Hosted Data: Architectural principle for enterprise versions where the core SigFile data (JSON files, database, indexes) resides entirely within the customer's infrastructure for maximum security and control.

3. High-Level Architecture

Phase 1/2 (Local Focus):

Command Line Interface (CLI) tool (sigfile).

Local storage (e.g., .sigfile/ directory with JSON files, potentially evolving to SQLite).

Integration with local Git repository (subprocess calls).

Manual invocation of local signing tools (e.g., GPG).

Phase 3/4 (Distributed/Enterprise):

Customer Environment:

SigFile Data Store (Database like PostgreSQL, Vector DB).

Ingestion/Indexing Pipeline (Containerized service provided by vendor).

Retrieval API (Secure endpoint hosted by customer).

(Optional) On-prem LLM agent components.

Vendor Environment / Developer Machine:

IDE Plugins / Client Applications.

Core Agent Logic (can call Customer Retrieval API and external LLM APIs).

Telemetry Collection Endpoint (Receives anonymized data).

Interaction Flow: IDE Plugin -> Agent Logic -> (Optional) External LLM -> Customer Retrieval API -> Customer Data Store.

4. Phased Rollout Plan

Phase 1: Foundation (Alpha - Solo Dev Focus)

Goal: Validate core workflow, capture basic rationale linked to commits.

Features:

CLI tool (sigfile add, sigfile find).

Basic JSON storage (sigfile.json or similar per-project).

Link entry to single file + latest commit hash for that file.

Fields: id, timestamp, author (manual input), file_path, commit_hash, rationale (as description), tags.

Minimal find by tag/file.

Manual GPG signing step encouraged/documented but not integrated.

Basic unit tests.

Clear README with vision and usage.

Target: Solo developers, early adopters willing to use CLI.

Phase 2: Enhancements & Usability (Beta - Early Teams)

Goal: Improve usability, data structure, search, and prepare for wider feedback.

Features:

Refined CLI commands and arguments (argparse).

Optional SQLite backend for local storage (handles larger histories better).

Improved schema: Add decision_type, task_id (manual grouping), proper author_id, multiple linked_files.

Entry IDs use UUIDs.

Enhanced find (by task_id, date range, author).

Integrated (optional) GPG signing via CLI command/flag (using system GPG).

Verification command (sigfile verify).

Basic, opt-in, anonymized telemetry (usage counts, errors).

Initial exploration/prototype of VS Code plugin (triggering manual CLI commands).

Target: Small teams, open-source community feedback.

Phase 3: Agent Foundation & Enterprise Prep (V1.0)

Goal: Enable basic AI context retrieval, provide customer-hosted deployment option.

Features:

Packaging for customer-hosted components (Docker containers for Indexer/API).

Defined Retrieval API specification.

Basic Agent functionality (IDE Plugin): Select code -> Ask "Why?" -> Agent queries Customer API -> Displays relevant log rationale(s). (Requires LLM call for synthesis).

Basic semantic search capability (requires vector embedding during ingestion).

Robust error handling and logging.

Initial placeholder support for RBAC in data/API.

Documentation for customer deployment.

Target: Technically capable teams, early enterprise pilots needing self-hosting.

Phase 4: Proactive Agent & Enterprise Suite (V2.0)

Goal: Deliver proactive AI guidance and full enterprise feature set.

Features:

Proactive Agent: Detect potential issues based on user input/code changes by querying historical logs (e.g., "This approach was rejected before...").

Full RBAC implementation.

Admin Dashboard (user management, usage stats - requires telemetry or customer API extension).

SSO Integration (SAML/OAuth).

Formalized Snapshot linking (metadata field to reference external snapshots).

Advanced reporting/analytics capabilities (via API).

Enhanced security auditing features.

Target: Large enterprises, regulated industries.

Future: Deeper AI integrations (fine-tuning customer-side models), broader IDE support, automated snapshotting options, advanced analytics.

5. Security Considerations

Customer-Hosted Data: Primary strategy for data confidentiality.

Digital Signatures: Ensure integrity, authenticity, non-repudiation of logs. PKI management is crucial.

Secure API: Customer-hosted Retrieval API must be secured (authentication, authorization, HTTPS).

Telemetry: Strict anonymization, transparency, opt-in/out.

Dependencies: Regularly scan and update dependencies.

Input Sanitization: Protect against injection attacks if SigFile data is ever displayed in web UIs.


